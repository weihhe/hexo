title: 基于 Raft的k-v存储系统
author: weihehe
tags:
  - Raft
  - 存储
categories:
  - 项目
date: 2024-09-12 11:53:00
---

`K-V`存储的分布式数据库
<!--more-->


# 项目构成

## Raft算法

### 持久化

**持久化内容**

在Raft共识算法和键值数据库（kvDb）的上下文中，持久化的内容主要分为两部分：

1. **Raft节点的部分信息**：
  - **m_currentTerm**：当前节点的任期（Term）。这是Raft算法中的一个核心概念，用于区分不同的选举周期。持久化当前任期是为了避免在系统重启后重新进入同一个任期（此时会导致重复投票）。
  - **m_votedFor**：当前任期内，节点已经投票给哪个候选者（或自己）。这是为了防止节点在系统故障重启后重复投票给同一个候选者。
  
  - **m_logs**：Raft节点保存的全部日志信息。日志是Raft算法中记录状态变更历史的关键数据结构，持久化日志可以确保在系统重启后能够恢复到之前的一致状态。
  
2. **kvDb——键值数据库的快照**：快照是kvDb在某个特定时间点的完整状态记录。它包含了恢复数据库到该状态所需的所有信息。通过持久化快照，可以加速数据库在系统崩溃后的恢复过程，同时减少恢复过程中需要处理的数据量。

**其他未持久化的信息**

虽然Raft算法和kvDb中有许多其他重要信息，但并不是所有信息都需要持久化。例如，节点的身份（Leader、Follower、Candidate）、commitIndex（已提交的日志索引）、applyIndex（已应用到状态机的日志索引）等信息在某些实现中可能不会被持久化。

- **身份**：节点的身份在Raft算法中是动态变化的，且这种变化通常是由算法逻辑控制的。因此，在系统重启后，节点可以通过重新加入集群并遵循Raft算法规则来重新获取其身份。
- **commitIndex**（已提交的日志索引）：虽然`commitIndex`是确保日志一致性的关键索引，但它可以通过日志的持久化间接得到保证。在系统重启后，通过比较本地日志和集群中其他节点的日志，节点可以重新计算出commitIndex。

- **applyIndex**（已经应用到状态机的日志索引）：在某些经典Raft实现中，它可能不会被持久化，因为即使丢失了applyIndex，节点仍然可以通过重新遍历日志并应用所有未应用的日志条目来恢复状态机到最新状态。

### 如何实现持久化

其实持久化是一个非常难的事情，因为持久化需要考虑：速度、大小、二进制安全。

因此仓库实现目前采用的是使用`boost`库中的持久化实现，将需要持久化的数据序列化转成`std::string`类型再写入磁盘。

## 跳表实现的存储引擎

