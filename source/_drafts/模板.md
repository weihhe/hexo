title: 模板
author: weihehe
date: 2024-07-10 16:09:44
tags:
---

模板相关
<!-- more-->

## 范型

如何实现泛型？

- 函数重载
- 模板
	- 类模板
	- 函数模板
    
```cpp
//函数模板
template<typename T1, typename T2,......,typename Tn>
返回值类型 函数名(参数列表){}

//类模板
```
上述代码中，中`typename`是用来定义模板参数关键字，也可以使用`class`。

### 重载存在的问题
1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数。

2. 代码的可维护性比较低，一个出错可能所有的重载均出错。

### 函数模板

函数模板是编译器用使用方式产生特定具体类型函数的模具。所以其实**模板**就是将本来应该**我们本该重复的事情交给了编译器**。

![函数模板生成对应的重载函数](/images/模板_函数模板.png)

#### 函数模板的实例化

- 隐式实例化——让编译器根据实参推演模板参数的实际类型。

- 显式实例化——在函数名后的<>中指定模板参数的实际类型。例如：
```cpp
my_FuncName<type>(date, date);
```

#### 模板参数的匹配原则

- 个**非模板函数**可以和一个**同名的函数模板同时存在。**并且在调动时会优先调用非模板函数而不会从该模板产生出一个实例。**如果模板可以产生一个具有更好匹配的函数，那么将选择模板。**
- 模板函数**不允许自动类型转换**，但普通函数可以进行自动类型转换。

#### 非类型模板参数



### 类模板

允许**以一个类当作蓝本，无需重复代码，创建管理着不同类型数据的类**。

```cpp
template<class T1, class T2, ..., class Tn>
class 类模板名
{
 // 类内成员定义，使用T当作类型的占位符
};
```
#### 类模板的实例化
```cpp
MyTemplateClassName<type> classNumber;
```

### 注意
- 注意：类模板中函数放在类外进行定义时，需要加模板参数列表
