title: 组合 内部类
author: weihehe
tags: []
categories:
  - C++
  - ''
date: 2023-07-03 18:01:00
---
C++中的组合
<!-- more -->

## 形式

```c++

class C{

};
class E{
privite:
	C _cc;
};
```
1. 继承允许你根据**基类的实现来定义派生类的实现**。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。**“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见**。
2. **继承一定程度破坏了基类的封装**，基类的改变，对派生类有很大的影响。
3. **派生类和基类**间的依赖关系很强，**耦合度高**。
4. 优先使用对象组合，而不是类继承。**组合的耦合度低，代码维护性好**。

### 继承和组合的理解

**形象来说**

1. ：public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象（例如：同学都是人）。

2. 组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象（例如：书包里有书）。

## 内部类（Nested Class）

- 是定义在另一个类的内部的类。内部类的主要目的是将类组织在一起，从而表示一种包含关系或逻辑上的联系。
  
- 内部类可以访问其外部类的成员（包括私有成员）
  

### 内部类的定义与使用

```cpp
#include <iostream>

class Outer {
public:
    // 外部类中的成员函数
    void display() const {
        std::cout << "Outer class display function" << std::endl;
    }

    // 定义一个内部类
    class Inner {
    public:
        void innerDisplay() const {
            std::cout << "Inner class display function" << std::endl;
        }

        // 内部类可以访问外部类的成员
        void accessOuter(const Outer& outer) const {
            outer.display();
        }
    };
};

int main() {
    // 创建外部类对象
    Outer outerObj;

    // 创建内部类对象
    Outer::Inner innerObj;

    // 调用内部类的成员函数
    innerObj.innerDisplay();

    // 通过内部类对象访问外部类的成员函数
    innerObj.accessOuter(outerObj);

    return 0;
}
```

- 结果分析：
  
  - 调用内部类的`innerDisplay()`函数输出"Inner class display function"。
    
  - 通过`innerObj`调用`accessOuter()`函数，从而间接调用外部类的`display()`函数，输出"Outer class display function"。