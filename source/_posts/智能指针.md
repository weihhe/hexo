title: '智能指针 '
author: weihehe
tags:
  - 指针
categories:
  - C++
date: 2024-08-09 17:57:00
---

C11中自带垃圾回收
<!--more-->

# 概念

- **RAII**（Resource Acquisition Is Initialization）:是通过借助一个对象的声明周期来控制资源的一种技术。
	- 智能指针就利用了`RAII`技术。

# std::auto_ptr（C++98，慎用）

- 管理权限转移，拷贝时，**会把被拷贝的对象的资源的管理权限转移给拷贝对象**，导致被拷贝对象**悬空**，访问就会出现问题。

# std::unique_ptr（C++11）

- **不允许拷贝构造，也不允许拷贝赋值运算符**。

#  std::shared_ptr(C++11)

- 支持拷贝赋值和允许拷贝赋值运算符。
- 但是存在**循环引用问题**。

## 循环引用问题

例如两个`shared_ptr`对象通过两个指针`prev`,`next`相互连接，它们相互为对方提供一个`引用计数`，导致**双方的引用计数始终不为0，从而导致循环引用**。

## shared_ptr模拟实现

```cpp
#include <iostream>
#include <utility>
#include <string>

using namespace std;

template <class T>
class SmartPtr
{
public:
    // 构造函数
    explicit SmartPtr(T *ptr)
        : _ptr(ptr), _counter(new int(1))
    {
    }

    // 析构函数
    ~SmartPtr()
    {
        if (--*(_counter) == 0)
        {
            cout << "free" << endl;
            delete _ptr;
            delete _counter;
        }
    }

    SmartPtr(const SmartPtr<T> &smartPtr)
        : _ptr(smartPtr._ptr),
         _counter(smartPtr._counter)
    {
        cout << "拷贝构造"<<endl;
        ++(*_counter);
    }

    // 赋值拷貝运算符
    SmartPtr<T> &operator=(SmartPtr &other)
    {
        if (_ptr != other._ptr)
        {
            if (--*(_counter) == 0)
            {
                cout << "赋值拷贝中的清0" << endl;
                delete _ptr;
                delete _counter;
            }
            cout << "赋值拷贝" << endl;
            _counter = other._counter;
            _ptr = other._ptr;
            ++(*_counter);
        }
        return *this;
    }

    // 禁用拷贝构造函数和拷贝赋值运算符
    // SmartPtr(const SmartPtr& other) = delete;
    // SmartPtr& operator=(const SmartPtr& other) = delete;

    T *input_ptr()
    {
        return _ptr;
    }
    T *output_ptr()
    {
        return _ptr;
    }
    T &operator*()
    {
        return *_ptr;
    }
    T *&operator->()
    {
        return _ptr;
    }

private:
    T *_ptr;
    int *_counter;
};

int main()
{
    SmartPtr smartPtr_pair(new pair<string, string>("first", "second")); 
    SmartPtr smartPtr_int(new int(5));

    SmartPtr smartPtr_str1(new string("abcd"));
    SmartPtr smartPtr_str2(smartPtr_str1);

    SmartPtr smartPtr_double1(new double(3.14));
    SmartPtr smartPtr_double2(new double(3.15)); 
    smartPtr_double1 = smartPtr_double2;

    cout << smartPtr_pair->first << " " << smartPtr_pair->second << endl; // 省略了一个箭头
    cout << *smartPtr_int << endl;
    /*输出  first second
            5
            free
            free */
    return 0;
}


```
- pair有省略一个箭头的情况。

# std::weak_ptr

- 不是使用`RAII`的智能指针，而是专门用来解决循环引用问题的指针。
	- 不增加引用计数，也不参与资源的管理，但是可以访问资源。

