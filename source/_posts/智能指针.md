title: '智能指针 '
author: weihehe
tags:
  - 指针
categories:
  - C++
date: 2024-08-09 17:57:00
---
更安全的进行资源管理
<!--more-->

# 概念

- 存在`<memory>`头文件中。
- **RAII**（Resource Acquisition Is Initialization）:是通过借助一个对象的声明周期来控制资源的一种技术。
	- 智能指针就利用了`RAII`技术。

# std::auto_ptr（C++98，慎用）

- `template <class X> class auto_ptr;`

- 管理权限转移，拷贝时，**会把被拷贝的对象的资源的管理权限转移给拷贝对象**，导致被拷贝对象**悬空**，访问就会出现问题。

# std::unique_ptr（C++11）

- `template <class T, class D = default_delete<T>> class unique_ptr;`
- **不允许拷贝构造，也不允许拷贝赋值运算符**。

#  std::shared_ptr(C++11)


- `template <class T> class shared_ptr;`
- 支持拷贝赋值和允许拷贝赋值运算符。
- 但是存在**循环引用问题**。

# 简单使用
```cpp
#include <iostream>
#include <memory>
using namespace std;

template <class T>
struct FreeFunc
{
    void operator()(T *ptr)
    {
        cout << "free:" << ptr << endl;
        free(ptr);
    }
};
template <class T>
struct DeleteArrayFunc
{
    void operator()(T *ptr)
    {
        cout << "delete[]" << ptr << endl;
        delete[] ptr;
    }
};
int main()
{
    FreeFunc<int> freeFunc;
    std::shared_ptr<int> sp1((int *)malloc(4), freeFunc);
    DeleteArrayFunc<int> deleteArrayFunc;
    std::shared_ptr<int> sp2((int *)malloc(4), deleteArrayFunc);

    std::shared_ptr<FILE> sp5(fopen("test.txt", "w"), [](FILE *p)
                              { fclose(p); });

    return 0;
}


```

## 循环引用问题

例如两个`shared_ptr`对象通过两个指针`prev`,`next`相互连接，它们相互为对方提供一个`引用计数`，导致**双方的引用计数始终不为0，从而导致循环引用**。

## shared_ptr模拟实现

```cpp
#include <iostream>
#include <utility>
#include <string>

using namespace std;

template <class T>
class SmartPtr
{
public:
    // 构造函数
    explicit SmartPtr(T *ptr)
        : _ptr(ptr), _counter(new int(1))
    {
    }

    // 析构函数
    ~SmartPtr()
    {
        if (--*(_counter) == 0)
        {
            cout << "free" << endl;
            delete _ptr;
            delete _counter;
        }
    }

    SmartPtr(const SmartPtr<T> &smartPtr)
        : _ptr(smartPtr._ptr),
         _counter(smartPtr._counter)
    {
        cout << "拷贝构造"<<endl;
        ++(*_counter);
    }

    // 赋值拷貝运算符
    SmartPtr<T> &operator=(SmartPtr &other)
    {
        if (_ptr != other._ptr)
        {
            if (--*(_counter) == 0)
            {
                cout << "赋值拷贝中的清0" << endl;
                delete _ptr;
                delete _counter;
            }
            cout << "赋值拷贝" << endl;
            _counter = other._counter;
            _ptr = other._ptr;
            ++(*_counter);
        }
        return *this;
    }

    // 禁用拷贝构造函数和拷贝赋值运算符
    // SmartPtr(const SmartPtr& other) = delete;
    // SmartPtr& operator=(const SmartPtr& other) = delete;

    T *input_ptr()
    {
        return _ptr;
    }
    T *output_ptr()
    {
        return _ptr;
    }
    T &operator*()
    {
        return *_ptr;
    }
    T *&operator->()
    {
        return _ptr;
    }

private:
    T *_ptr;
    int *_counter;
};

int main()
{
    SmartPtr smartPtr_pair(new pair<string, string>("first", "second")); 
    SmartPtr smartPtr_int(new int(5));

    SmartPtr smartPtr_str1(new string("abcd"));
    SmartPtr smartPtr_str2(smartPtr_str1);

    SmartPtr smartPtr_double1(new double(3.14));
    SmartPtr smartPtr_double2(new double(3.15)); 
    smartPtr_double1 = smartPtr_double2;

    cout << smartPtr_pair->first << " " << smartPtr_pair->second << endl; // 省略了一个箭头
    cout << *smartPtr_int << endl;
    /*输出  first second
            5
            free
            free */
    return 0;
}


```
- pair有省略一个箭头的情况。

# std::weak_ptr

- template <class T> class weak_ptr;
- 不是使用`RAII`的智能指针，而是专门用来解决循环引用问题的指针。
	- 不增加引用计数，也不参与资源的管理，但是可以访问资源。
    
# 资源控制器的简单模拟

- 使用一个**可调用对象**来对智能指针申请到的资源进行管理。
	- 如下代码使用包装器来让析构函数正确的调用我们指定的析构方法。

```cpp
#include <iostream>
#include <utility>
#include <string>
#include <functional>

using namespace std;

template <class T>
class SmartPtr
{
public:
    template <class D>
    SmartPtr(T *ptr,D del)
        : _ptr(ptr), _counter(new int(1)),
        _del(del)
    {
    }
    // 析构函数
    ~SmartPtr()
    {
        if (--*(_counter) == 0)
        {
            cout << "free" << endl;
            //delete _ptr;
            _del(_ptr);
            delete _counter;
        }
    }

private:
    T *_ptr;
    int *_counter;
    function<void(T*)> _del;
};

int main()
{

    SmartPtr<string> smartPtr_str(new string("abcd"),[](string* ptr){delete(ptr);cout<<"资源管理器";});
    /*输出：free
            资源管理器*/
    return 0;
}

```