title: 读者写者问题 读写锁
author: weihehe
tags: []
categories:
  - 多线程
date: 2024-08-02 09:16:00
---

读者写者问题的简单汇总

<!--more-->

## 概念

- 在编写多线程的时候，有一种情况是十分常见的。那就是，有些公共数据修改的机会比较少。相比较改写，它们读的机会反而高的多。通常而言，在读的过程中，往往伴随着查找的操作，中间耗时很长。给这种代码段加锁，会极大地降低我们程序的效率。

- 而读写锁(`pthread_rwlock_init`)可以专门处理这种**多读少写**的情况。——如果不采用读写锁，那么由于**读者对锁的竞争能力更强，可能导致写者的饥饿问题。**

## 关系

- **写者** 与 **读者**:互斥。
- **写者** 与 **写着**:互斥。
- **读者** 与 **读者**：共享。


## 读写锁接口

| 函数                                    | 描述                                                                 |
|-----------------------------------------|----------------------------------------------------------------------|
| `pthread_rwlockattr_setkind_np`         | 设置读写优先。                                                       |
| `pthread_rwlock_init`                   | 初始化读写锁。                                                       |
| `pthread_rwlock_destroy`                | 销毁读写锁。                                                         |
| `pthread_rwlock_rdlock`                 | 获取读锁。如果读锁已经被其他线程持有，则当前线程会阻塞。             |
| `pthread_rwlock_wrlock`                 | 获取写锁。如果写锁已经被其他线程持有，则当前线程会阻塞。             |
| `pthread_rwlock_unlock`                 | 释放读锁或写锁。                                                     |

## 设置读写优先

```cpp
int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *attr, int pref);
````

## 选项

`pref` 共有 3 种选择：

- `PTHREAD_RWLOCK_PREFER_READER_NP` (默认设置)：读者优先，可能会导致写者饥饿情况。
- `PTHREAD_RWLOCK_PREFER_WRITER_NP`：写者优先，目前有 BUG，导致表现行为和 `PTHREAD_RWLOCK_PREFER_READER_NP` 一致。
- `PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP`：写者优先，但写者不能递归加锁。

## 初始化

```cpp
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
```

## 销毁

```cpp
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```

## 加锁和解锁

```cpp
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```
