title: 程序替换 exec函数 .cpp调用.py
author: weihehe
tags:
  - 程序替换
categories:
  - 操作系统
date: 2024-07-16 09:56:00
---
在子进程中，执行和父进程完全不同的代码
<!--more-->

## 概念

程序替换的一种方法：`execl`

- 标准写法 `execl("/usr/bin/ls","ls","-a","-l",NULL)`参数列表结尾规定为`NULL`。

- 在`execl`之后的代码不会被执行（但如果替换失败，还是会执行后续代码的）。程序会被替换为`ls`程序相关的内容，并且重新开始执行替换之后的程序。

![替换过程](/images/程序替换-替换过程.png)
- 程序替换**不会创建新进程**，因此也不会创建新的`PCB`。 

*这里举例是用`ls`程序替换的过程*

`exec`系列函数，只有运行**失败情况的返回值**，**没有成功情况的返回值**（程序都被替换了，也没有可以接受返回值的函数）。

## 原理

- 单进程情况：将原先程序的页表中保存的`物理地址`，更改为`ls`程序对应的`物理地址`。

- Linux中形成的可执行程序，是有格式的，即——`ELF`。其文件特征是，在程序的最开始，会存在一个的表头，其中记录了多项信息，其中就包括可`执行程序的入口函数地址`。因此完成了程序替换之后，能够重新运行新的程序。

- **并且，程序替换不会替换环境变量。而是根据进程的父子关系从上往下传递。**

### exec系列函数

- 所有系列函数开头是都是exec。
- 命名规律
	- l(list) : 表示参数采用列表
	- v(vector) : 参数用数组的方式保存
	- p(path) : 自动搜索环境变量PATH
	- e(env) : 表示自己维护环境变量
  
对于表格中的部分参数举例：
- `char *const envp[] = {"PATH=/bin:/usr/bin", "TERM=console", NULL};`
- `char *const argv[] = {"ps", "-ef", NULL};`
    
| Function       | Description                                                                 | Usage Example                                                   |
|----------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------|
| `execl`        | Executes a program, taking a list of arguments.                             | `execl("/bin/ls", "ls", "-l", (char *)NULL);`                   |
| `execle`       | Executes a program, taking a list of arguments and an environment list.     | `execle("/bin/ls", "ls", "-l", (char *)NULL, envp);`            |
| `execlp`       | Executes a program, searching for it in the `PATH` environment variable.    | `execlp("ls", "ls", "-l", (char *)NULL);`                       |
| `execv`        | Executes a program, taking an array of arguments.                           | `char *args[] = {"ls", "-l", NULL}; execv("/bin/ls", args);`    |
| `execve`       | Executes a program, taking an array of arguments and an environment list.   | `char *args[] = {"ls", "-l", NULL}; execve("/bin/ls", args, envp);` |
| `execvp`       | Executes a program, searching for it in the `PATH` environment variable.    | `char *args[] = {"ls", "-l", NULL}; execvp("ls", args);`        |

### 脚本语言

- 所有的脚本语言都要以`#!`开头，后面跟上**解释器**的路径。由**解释器**逐行来解释我们的**脚本语言的内容**。

*shell脚本中的函数调用不需要圆括号*

### 调用

例如：
- 使用`execle()`调用以下python程序`：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    printf("fork above\n");
    fflush(stdout);  // 刷新标准输出缓冲区
    char *const envp[] = { NULL };
    execle("/usr/bin/python3", "python3", "test.py", (char *)NULL, envp);
    perror("execle");  // execle()返回时表示失败
    return 0;
}

```
.py文件内容
```python
#!/usr/bin/python3
print("hello cpp&python")
```