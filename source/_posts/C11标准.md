title: C11
author: weihehe
date: 2024-07-10 14:08:44
tags:
---
C11标准
<!-- more -->


- {} 初始化（**列表初始化**）
  
  - 所有容器均支持`{}`的初始化，并且可以不写`=`。但要注意**保持代码可读性**。
  - 对于**自定义类型，还会调用构造函数**。
  - 相较于构造函数的单参数隐式类型转换，{}**支持多参数的隐式类型转换。**
  - 并且创建的**临时对象**同样具有**常性**。
  
```cpp
---
int* ptr1 = new int[3]{1,2,3};

My_class* ptr2 = new My_class[2]{e1,e2};

---
```
- **initializer_list**:
	- 对于常量数组，创建了一个新的类型`std::initializer_list`。

	- 这样就导致了如下的语句在C++11中不能使用。

	- `const int* ptr1 = {1,2,3};`，因为花括号内会被识别为`std::initializer_list`

- **auto:**:

	- 其用于**定义变量时，自动识别类型**。要求必须进行显示初始化,例如：`auto pf = malloc`创建一个指向`malloc`的函数指针。
	- `typeid(var).name()`可以查看`var`的类型,返回值是一个字符串。

- **decltype:**:

	- 也可以自动识别对象,表达式的类型，可以用于定义变量或者作为模板实参。 例如：
		- `decltype<var> new_var`
		- `F_Name<decltype(var)> new_var`

- **nullptr:**:
	- 由于C++中NULL被定义成字面量0，这样就可能回带来一些问题，因为0既能指针常量，又能表示整形常量。所以出于清晰和安全的角度考虑，C++11中新增了nullptr，用于表示空指针。

- **新增容器:**
	- `unordered_map`
	- `unordered_set`

	- `template<class T,std::size_t N> struct array;`静态数组。
	- `template<classT,classAllocator = std::allocator<T>> classforward_list;`
单链表。

- **cbein，cend**

- **所有容器均支持emplace**。

	- emplace系列函数提供了一种在容器中直接构造元素的方法。这与insert或push_back等方法不同，后者通常需要先构造对象然后再将其复制或移动到容器中，而emplace则是在容器的内部直接构造对象，从而避免了不必要的拷贝或移动操作。

```cpp

template <class... Args>iterator emplace (const_iterator position, Args&&... args);

```
