title: 精巧写法
author: weihehe
tags: []
categories:
  - 数据结构与算法
date: 2024-07-13 12:23:00
---
思路或代码
<!-- more -->
## .C:

### 假设现有一个结构体S，内部包含一个双向链表结构L....目前已知某个结构体S上的L的地址，如何访问S的其他成员？()（）

1.`&((My_struct*)0 -> link)`,得到link在struct当中相对于**结构体首地址**的偏移量。
2. 使用`（L - &((My_struct*)0 -> link)）`通过让L指针（向上）移动，获得了L地址对应结构体首地址——即结构体地址。
    *两个相同类型的指针相减的结果，等于他们之间元素的个数。*
3. 强转并且使用结构体指针访问其他成员`（My_struct*）（L - &((My_struct*)0 -> link)）->_other`
    
**调整需要管理员权限**

### linux内核的`O（1）`调度算法

采用了两个二级指针，分别指两个指针数组。并且可以用`位图`的方式，来记录某个`PRI`值对应的队列是否为空。

正在被调度的进程，按照图中正在处理。

![调度器分配图](/images/调度器分配图.png)

新添加的进程，则也根据`PRI`，保存到`*waiting[]`相应的位置。(`*runing[]` 和 `*waiting[]`的存储逻辑是相同的)等到 **`*runing[]`处理完毕之后，`swap（**run,**wait）`，让新添加的进程被调度**。


由于PRI较低的在头部，优先被遍历，故优先被执行。