title: 精巧写法
author: weihehe
tags: []
categories:
  - 数据结构与算法
date: 2024-07-13 12:23:00
---
思路或代码
<!-- more -->

## `引用计数`来对一个资源进行管理，让其可以正确的释放资源。
- 例如：`shared_ptr`的实现。

## 假设现有一个结构体S，内部包含一个双向链表结构L....目前已知某个结构体S上的L的地址，如何访问S的其他成员？()（）

1.`&((My_struct*)0 -> link)`,得到link在struct当中相对于**结构体首地址**的偏移量。
2. 使用`（L - &((My_struct*)0 -> link)）`通过让L指针（向上）移动，获得了L地址对应结构体首地址——即结构体地址。
    *两个相同类型的指针相减的结果，等于他们之间元素的个数。*
3. 强转并且使用结构体指针访问其他成员`（My_struct*）（L - &((My_struct*)0 -> link)）->_other`。

## 标志位传参
```cpp
#include <stdio.h>

#define ONE (1 << 0)    // 1
#define TWO (1 << 1)    // 2
#define THREE (1 << 2)  // 4
#define FOUR (1 << 3)   // 8

void show(int flags) {
    if (flags & ONE) printf("function1\n");
    if (flags & TWO) printf("function2\n");
    if (flags & THREE) printf("function3\n");
    if (flags & FOUR) printf("function4\n");
}

int main() {
    show(ONE);
    show(TWO);
    show(ONE | TWO);
    show(ONE | TWO | THREE);
    return 0;
}

```
### output

```
function1
function2
function1
function2
function1
function2
function3
```
### 基本思想

传递一个整数，并用它的比特位为`1`或为`0`来代表`true`或`false`。

## linux内核的`O（1）`调度算法

采用了两个二级指针，分别指两个指针数组。并且可以用`位图`的方式，来记录某个`PRI`值对应的队列是否为空。

正在被调度的进程，按照图中正在处理。

![调度器分配图](/images/调度器分配图.png)

新添加的进程，则也根据`PRI`，保存到`*waiting[]`相应的位置。(`*runing[]` 和 `*waiting[]`的存储逻辑是相同的)等到 **`*runing[]`处理完毕之后，`swap（**run,**wait）`，让新添加的进程被调度**。


由于PRI较低的在头部，优先被遍历，故优先被执行。

## IP(uint32和string的转换)

![IP转换](/images/IP的转换.png)


