title: 传输控制协议 序列化 JSON
author: weihehe
tags:
  - 协议
categories:
  - 网络
date: 2024-08-18 14:21:00
---

网络工具
<!--more-->

## 概念

- read/wirte类似一种拷贝函数，负责**用户数据与系统缓冲区之间的数据传递**。然后由**传输控制协议**决定数据的收发。

- **协议**是计算机网络中用于定义通信**双方如何交换信息的规则和标准。协议规定了数据的格式、传输方式、如何建立和终止通信连接、错误处理方式等方面的内容**。

- 为了方便数据的发收和传输，会**对数据进行一些结构化的处理**，这个类似打包的过程就叫做**序列化**。将**结构化的数据提取出来**，解包的过程就叫做**反序列化**。


## 现成的序列化工具

### JSON (JavaScript Object Notation)

- **定义**: JSON 是一种轻量级的数据交换格式，易于人类阅读和编写，也易于机器解析和生成。它基于文本并使用键值对表示数据结构。
	- 为了可以让cpp使用JSON，需要使用`jsoncpp`库
- **格式**: 文本格式，使用花括号 `{}` 表示对象，方括号 `[]` 表示数组，数据类型包括字符串、数字、布尔值、数组、对象等。

- CPP中JSON的使用,需要安装libjsoncpp-dev 
	- `$ g++ -o json json.cpp -std=c++11 -ljsoncpp`

```cpp
#include<jsoncpp/json/json.h>
#include <iostream>

int main()
{
    Json::Value root;//万能对象
    root["a"] = 100;
    root["b"] = 200;
    root["op"] = '+';
    root["res"] = "=300";

    //序列化
    Json::FastWriter w;
    std::string res = w.write(root);
    std::cout<<res<<std::endl;

    //风格序列化，可读性更好
    Json::StyledWriter fw;
    res = fw.write(root);
    std::cout<<res<<std::endl;

    //反序列化
    Json::Value v;
    Json::Reader r;
    r.parse(res,v);

    //提取数据
    int a = v["a"].asInt();
    int b = v["b"].asInt();
    char op = v["op"].asInt();
    res = v["res"].asString();

    std::cout<<a<<" "<<b<<" "<<op<<" "<<res<<std::endl;

    return 0;
}
```

```output
{"a":100,"b":200,"op":43,"res":"=300"}

{
   "a" : 100,
   "b" : 200,
   "op" : 43,
   "res" : "=300"
}

100 200 + =300
```

### Protobuf (Protocol Buffers)

- **定义**: Protobuf 是由 Google 开发的一种高效的序列化格式，用于结构化数据的序列化和反序列化。它使用二进制格式，设计目的是提高性能和效率。

- **格式**: 二进制格式，基于预定义的消息结构。需要通过 `.proto` 文件定义数据结构（消息）。


