title: 建造者模式
author: weihehe
tags: []
categories:
  - 设计模式
date: 2024-09-21 14:14:00
---

一种设计模式
<!--more-->

## 使用情景：

- 将一个复杂对象的**构建与其表示分离**。
  
- 通过**使用相同的抽象建造者，并通过具体建造者的类型可以创建不同的对象。**。
  

### 建造者模式的核心角色

- **产品**：要构建的复杂对象。

- **抽象建造者**：为创建产品对象的各个部件指定抽象接口。

- **具体建造者**：实现`Builder`接口以构造和装配该产品的各个部件。

- **指挥者**：构造一个使用`Builder`接口的对象。

### 举例

#### 1. 定义产品类

首先，定义一个电脑（`Computer`）类，这是我们要构建的产品。

```cpp
#include <iostream>  
#include <string>  
  
class Computer {  
public:  
    void setCPU(const std::string& cpu) { cpu_ = cpu; }  
    void setRAM(const std::string& ram) { ram_ = ram; }  
    void setStorage(const std::string& storage) { storage_ = storage; }  
    void displayInfo() {  
        std::cout << "CPU: " << cpu_ << std::endl;  
        std::cout << "RAM: " << ram_ << std::endl;  
        std::cout << "Storage: " << storage_ << std::endl;  
    }  
  
private:  
    std::string cpu_;  
    std::string ram_;  
    std::string storage_;  
};
```

#### 2. 定义抽象建造者类

接着，定义一个抽象建造者（`ComputerBuilder`）类，它定义了构建电脑各个部件的抽象接口。

```cpp
class ComputerBuilder {  
public:  
    virtual ~ComputerBuilder() {}  
    virtual void buildCPU() = 0;  
    virtual void buildRAM() = 0;  
    virtual void buildStorage() = 0;  
    virtual Computer getResult() = 0;  
};
```

#### 3. 定义具体建造者类

如高性能电脑建造者（`HighPerformanceComputerBuilder`）和普通电脑建造者（`StandardComputerBuilder`），它们实现了抽象建造者接口。

```cpp
class HighPerformanceComputerBuilder : public ComputerBuilder {  
public:  
    void buildCPU() override { computer_.setCPU("High-end CPU"); }  
    void buildRAM() override { computer_.setRAM("16GB RAM"); }  
    void buildStorage() override { computer_.setStorage("1TB SSD"); }  
    Computer getResult() override { return computer_; }  
  
private:  
    Computer computer_;  
};  
  
class StandardComputerBuilder : public ComputerBuilder {  
public:  
    void buildCPU() override { computer_.setCPU("Standard CPU"); }  
    void buildRAM() override { computer_.setRAM("8GB RAM"); }  
    void buildStorage() override { computer_.setStorage("500GB HDD"); }  
    Computer getResult() override { return computer_; }  
  
private:  
    Computer computer_;  
};
```

#### 4. 定义指挥者类

负责协调具体建造者以正确的顺序构建产品。

```cpp
class HighPerformanceComputerBuilder : public ComputerBuilder {  
public:  
    void buildCPU() override { computer_.setCPU("High-end CPU"); }  
    void buildRAM() override { computer_.setRAM("16GB RAM"); }  
    void buildStorage() override { computer_.setStorage("1TB SSD"); }  
    Computer getResult() override { return computer_; }  
  
private:  
    Computer computer_;  
};  
  
class StandardComputerBuilder : public ComputerBuilder {  
public:  
    void buildCPU() override { computer_.setCPU("Standard CPU"); }  
    void buildRAM() override { computer_.setRAM("8GB RAM"); }  
    void buildStorage() override { computer_.setStorage("500GB HDD"); }  
    Computer getResult() override { return computer_; }  
  
private:  
    Computer computer_;  
};
```

最后，在客户端代码中，使用指挥者来构建具体的产品对象。

```cpp
int main() {  
    Director director;  
    HighPerformanceComputerBuilder highPerformanceBuilder;  
    Computer highPerformanceComputer = director.construct(highPerformanceBuilder);  
    std::cout << "High Performance Computer:" << std::endl;  
    highPerformanceComputer.displayInfo();  
  
    StandardComputerBuilder standardBuilder;  
    Computer standardComputer = director.construct(standardBuilder);  
    std::cout << "\nStandard Computer:" << std::endl;  
    standardComputer.displayInfo();  
  
    return 0;  
}
```