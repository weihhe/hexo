title: GCC生成可执行文件过程 静态库 动态库
author: weihehe
tags:
  - GCC
categories:
  - 操作系统
date: 2024-06-30 09:42:00
---
Linux下，gcc形成可执行程序的过程
<!--more-->

`gcc [选项] 要编译的文件 [选项] [目标文件]`

| 常见后缀和选项 | 功能  |
| --- | --- |
| -E  | gcc 在预处理结束后停止编译过程 |
| -o  | 目标文件 |
| .i  | 已经处理过的C原始程序 |
| -S  | 选项只进行编译而不进行汇编,生成汇编代码。 |
| -c  | 将汇编代码转化为.o的二进制目标文件 |
| -E  | 只激活预处理，这个不生成文件，你需要把它重定向到一个输出文件里面 |
| -S  | 编译到汇编语言不进行汇编和链接 |
| -c  | 编译到目标代码 |
| -o  | 文件输出到 文件 |
| -static | 此选项对生成的文件采用静态链接 |
| -g  | 生成调试信息。GNU 调试器可利用该信息。 |
| -shared | 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库。 |
| -O0 | 编译器的优化选项之一，表示没有优化 |
| -O1 | 编译器的优化选项之一，为缺省值 |
| -O2 | 编译器的优化选项之一 |
| -O3 | 编译器的优化选项之一，优化级别最高 |
| -w  | 不生成任何警告信息。 |
| -Wall | 生成所有警告信息。 |
| -std=c99 | 使用C99标准|
|-I（大i） | 指定路径下去寻找头文件|
|-L | （lib）指定去该路径下寻找库文件|
|-l（小L）| 指定库文件名称(去除前缀lib和后缀.a ，并且在-l后紧跟库名称  )
### gcc处理

1. **预处理**（进行宏替换)
  
  - 预处理功能主要包括宏定义,文件包 含,条件编译,去注释等。
  - 预处理指令是以#号开头的代码行。  
    `gcc -E hello.c o hello.i`
2. **编译**（生成汇编)
  
  - 在这个阶段中,gcc 首先要检査代 码的规范性、是否有语法错误等。以确定代码的实际要做的工作,在检查无误后,gcc 把代码翻译成汇编语言。  
    `gcc-s hello.io hello.s`
3. **汇编**（生成机器可识别代码）
  
  - 汇编阶段是把编译阶段生成 的“.s“文件转成目标文件。  
    `gcc-c hello.s -o hello.o`
4. **连接**
  
  - 在成功编译之后，就进入了链接阶段。
    
  - 可以**寻找缺少的函数的具体实现**，从库中或者从其他.obj文件。*替换原来的CALL的“虚假”地址。*
    
  - 分为**静态链接**和**动态链接**。
    
  - **动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所必需的动态库才能运行。**动态链接生成的程序体积较小，但是**必需依赖所需的动态库，否则无法执行**。
    
  - 静态链接使用静态库进行链接，**生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大**。  
    `gcc hel1o.o -o hello`
    

## 静态库(`.a`)和动态库(`.so`)

一部分函数实现会在系统**默认的搜索路径** `“/usr/lib`下的`libc.so.6` 的库文件中，并在链接的阶段被找到。

这些库文件又分为`动态库`和`静态库`。

### 静态库

- **静态库**是指**编译链接时,把库文件的代码全部加入到可执行文件中,因此生成的文件比较大,但在运行时也就不再需要库文件了**。

### 动态库

- 动态库在编译链接时，并没有把库文件的代码加入到可执行文件中,**而是在程序执行时由运行时链接文件加载库**,这样可以**节省系统资源**。后缀名一般为`.a`。
  
- 动态库一般后缀名为`.so`,如前面所述的 libc.so.6 就是动态库。gcc 在编译时**默认使用动态库**，如果要使用静态库，要加上`-static`。

### 打包库

如果我们想把我们写的方法给别人使用，可以采用以下方法：
1. 直接提供源文件,让别人编译。
2. 将我们的源代码打包成为一个库。


#### 打包静态库（以c语言为例）

原理：将`.c`文件编译为`.p`，然后将所有的`.o`文件打包。成一个`.a`的静态库，需要使用该库的时候，只需要包含进头文件(`.h`)，然后直接将其和`.o`文件连接即可。

#### 找到头文件的方法
- 寻找头文件，可以在文件的当前目录下，放入头文件。
- 或者在gcc编译的时候，加上`-I`选项，指定头文件的位置。

```Makefile
lib = libmyprogram.a

${lib}: mymath.o
	ar -rc $@ $^

mymath.o: mymath.c
	gcc -c $<

.PHONY: clean
clean:
	rm -f *.o *.a

.PHONY: output
output:
	mkdir -p lib/include
	cp *.h lib/include

    
```
- ${lib} 是一个变量，之前在 Makefile 中定义为 lib=libmyprogram。这意味着 ${lib} 实际上等同于 libmyprogram。

- ar是gnu归档工具(用于生成静态库)，rc表示(replace and create)
![使用静态库编译的时候，可能需要加上的若干选项](/images/静态库使用选项.png)

