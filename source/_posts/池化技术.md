title: 高性能内存池
author: weihehe
tags:
  - 池化
categories:
  - 项目
date: 2024-08-27 17:16:00
---
内存池项目过程中的一些重点
<!--more-->

# [项目GitHub地址](https://github.com/weihhe/High-concurrency-pool)

# 对象池（定长内存池）

- 定长：存储内容的大小是不变的。

## 1.如何将一段连续的空间的前几个字节单独赋予一个指针值

1. 使用强转可以将前几个字节提出来。

2. 由于不同操作系统的`指针大小`可能不同，我们可以使用二级指针来准确的`指针大小`。

```cpp
*(static_cast<void**>(abandonObj)) = nullptr;//链表结构
```

## 2. 对于申请的对象大小至少为一个指针的大小，便于使用链表回收。

## 3. `*(void**)`可以刚好取出一个指针大小的空间。

## 什么是内存碎片？

- 内存碎片是指在计算机内存管理中，内存被频繁分配和释放后，出现了大量的小块未被使用的内存区域，这些小块内存虽然总量上足够分配新的内存请求，但因为分散而无法满足较大连续内存需求的现象。

### 内存碎片类型

1. **外部碎片**：
  
  - 发生在堆内存（动态内存）中，是指内存中存在许多空闲块，但由于它们不是连续的，无法满足较大的内存分配请求。
2. **内部碎片**：
  
  - 发生在分配的内存块内部，是指分配的内存比实际需要的要大，多余的部分无法被使用或回收，导致浪费。

## 性能测试结果如下：

- 在数据量仅为`3*10^5`时，性能提升就十分明显。（Release 模式）

![性能测试](/images/pasted-20.png)


# 内存池

## 组成：

### Thread Cache(*无锁*)

- 每个线程独有的缓存，用于小于256KB的内存分配。
- 线程直接从此缓存申请内存，无需加锁，提升并发效率。
#### 实现：

- 多个进程的自由链表，根据每个进程对内存的需求不同从而匹配大小不同的链表。因为我们不能给所有大小都设置一个自由链表。而是梯度的设置自由链表。

- 对于每一种大小的线程，为了能将他们统一的存储起来，因此需要为它们需要引入对齐规则。
	- 因为对齐规则的存在，可能存在一定程度的内存浪费——内部碎片。
	- 如果对齐粒度过细，则可能会导致链表节点数过多。
	- 线程如何获取到`thread cache`？需要使用`TLS`,即——线程局部存储。`thread cache`是线程**独享，无锁的重要原因**的，并在该线程内具有全局可见性。（不同于常规的全局变量）

| 字节大小范围 | 对齐数 | 对应哈希桶范围 |
| --- | --- | --- |
| `[1, 128]` | 8 byte 对齐 | `freelist[0, 16)` |
| `[129, 1024]` | 16 byte 对齐 | `freelist[16, 72)` |
| `[1025, 8 * 1024]` | 128 byte 对齐 | `freelist[72, 128)` |
| `[8 * 1024 + 1, 64 * 1024]` | 1024 byte 对齐 | `freelist[128, 184)` |
| `[64 * 1024 + 1, 256 * 1024]` | 8 * 1024 byte 对齐 | `freelist[184, 208)`|

#### 运行过程

申请内存：

1. 当内存申请`size<=256KB`，先获取到线程本地存储的thread cache对象，计算size映射的哈希桶自由链表下标i。

2. 如果自由链表`_freeLists[i]`中有对象，则直接Pop⼀个内存对象返回。
  
3. 如果`_freeLists[i]`中没有对象时，则批量从`central cache`中获取⼀定数量的对象，插入到自由链表并返回⼀个对象。

释放内存：

1. 当释放内存小于256k时将内存释放回`thread cache`，计算size映射自由链表桶位置i，将对象Push
到`_freeLists[i]`。

2. 当链表的长度过长，则回收⼀部分内存对象到`central cache`。


### Central Cache（桶锁）

- 所有线程共享的缓存，Thread Cache 按需从 Central Cache 获取对象。

	- `span`，以页为单位的大块内存。只不过它内部仍然被切分为了和`Thread Cache`类似的小块内存。
    
- `Central Cache` 适时回收 `Thread Cache` 中的对象，避免单线程占用过多内存，保证多个线程之间的内存分配更均衡。

- 由于存在竞争，获取对象需要加锁，但通过桶锁和较少的访问频率降低竞争激烈程度。

	- 竞争：如果当线程1和线程2的自由链表都使用完后，他们都向`Central Cache`索要内存，但索要的都是`Central Cache`的同一个桶，那么就会发生竞争。

#### 条件编译分别`64`/`32`位机器

两者的页数量不同，64位环境下可能需要`unsigned long long`来存储。

### Page Cache

- 位于整个内存池结构的底部， 作为Central Cache 上层的缓存，以页为单位存储和分配内存。

- 当 Central Cache 缺少对象时，Page Cache 提供一定数量的页，切割为固定大小的小块内存分配给 Central Cache。

- 回收和合并相邻的页，减少内存碎片问题。

### Static和TLS
- 只能在当前文件内可见，`TLS`一定程度上依赖于此。并且每个线程使用`TLS`是不会由于进程切换而改变的。
- 通过TLS,每个线程无锁的获得自己专属的所需对象。
### 流程

1. 当一个线程被创建之后，