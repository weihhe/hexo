title: 模板
author: weihehe
tags:
  - 模板
categories:
  - C++
date: 2024-07-10 16:09:00
---

模板相关
<!-- more-->

## 范型

如何实现泛型？

- 函数重载
- 模板
	- 类模板
	- 函数模板
    
```cpp
//函数模板
template<typename T1, typename T2,......,typename Tn>
返回值类型 函数名(参数列表){}

//类模板
```
上述代码中，中`typename`是用来定义模板参数关键字，也可以使用`class`。

### 重载存在的问题
1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数。

2. 代码的可维护性比较低，一个出错可能所有的重载均出错。

### 函数模板

函数模板是编译器用使用方式产生特定具体类型函数的模具。所以其实**模板**就是将本来应该**我们本该重复的事情交给了编译器**。

![函数模板生成对应的重载函数](/images/模板_函数模板.png)

#### 函数模板的实例化

- 隐式实例化——让编译器根据实参推演模板参数的实际类型。

- 显式实例化——在函数名后的<>中指定模板参数的实际类型。例如：
```cpp
my_FuncName<type>(date, date);
```

### 类模板

允许**以一个类当作蓝本，无需重复代码，创建管理着不同类型数据的类**。

```cpp
template<class T1, class T2, ..., class Tn>
class 类模板名
{
 // 类内成员定义，使用T当作类型的占位符
};
```
#### 类模板的实例化

```cpp
MyTemplateClassName<type> classNumber;
```

## 模板参数的匹配原则

- 个**非模板函数**可以和一个**同名的函数模板同时存在。**并且在调动时会优先调用非模板函数而不会从该模板产生出一个实例。**如果模板可以产生一个具有更好匹配的函数，那么将选择模板。**

- 模板函数**不允许自动类型转换**，但普通函数可以进行自动类型转换。

- **非类型形参**，就是用一个**常量作为类(函数)模板**的一个参数，**在类(函数)模板中可将该参数当成常量来使用**。

## 函数模板特化

### 函数模板特化

目的，函数模板对于特殊的类型，生成特殊的方法。但对于一些参数类型复杂的函数模板，特化时特别给出，因此函数模板不建议特化。

**使用方法**

```cpp
1.初级的函数模板
template<class T>
bool Less(T left, T right)
{
	 return left < right;
}
2.空尖括号
template<>
3.函数名后跟一对尖括号，尖括号中指定需要特化的类型
bool Less<Date*>(Date* left, Date* right)/*4.函数形参表，必须要和模板函数的基础参数类型完全相同*/
{
	return *left < *right;
}
```
1. 必须要先有一个**基础的函数模板**。
2. 关键字template后面接一对空的尖括号<>
3. 函数名**后跟一对尖括号，尖括号中指定需要特化的类型**。
4. 对于**函数形参表，必须要和模板函数的基础参数类型完全相同**，如果不同编译器可能会报一些奇怪的错误。

### 类模板特化

- 全特化：全特化即是将模板参数列表中所有的参数都确定化。
- 偏特化：任何针对模版参数进一步进行条件限制设计的特化版本

## 注意

- 注意：**类模板中函数**放在**类外进行定义时，需要加模板参数列表**。
- 浮点数、类对象以及字符串是**不允许作为非类型模板**参数的。
- **非类型的模板参数必须在编译期就能确认结果**。
