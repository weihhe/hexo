title: 实现Json-Rpc
author: weihehe
tags:
  - 异步
  - 移动
  - Muduo
  - Json
  - Rpc
  - LV
  - ''
categories:
  - 项目
date: 2024-09-04 22:09:00
---
搭建Json-Rpc协议框架 异步操作
<!--more-->

# 项目设计

### RPC（远端调用）基本概念

- **本质**：RPC的核心思想是客户端将任务请求发送给服务器，由服务器完成处理并返回结果给客户端。
- **简单性**：从概念上讲，RPC并不复杂，它实现了客户端与服务端之间的任务委托和结果返回。

### RPC的分布式架构

- **问题**：传统的一对一或多对一模型存在服务端掉线导致客户端无法进行远端调用和服务端负载过高等问题。
- **解决方案**：

  - **分布式架构**：由多个节点（服务器）组成的系统，通过协同工作解决高并发问题，提高系统扩展性和可用性。
  
  - **注册中心**：增加注册中心**用于服务的注册与发现**。**服务器**向注册中心**注册自己能够提供的服务**，**客户端**在发起调用前**通过注册中心发现服务**。

### 分布式架构的优势

- **服务注册与发现**：服务提供者向注册中心注册服务，客户端通过注册中心发现服务，提高了系统的灵活性和可扩展性。

- **负载均衡**：客户端在请求RPC服务时，由于有多个RPC提供者可选，可以实现简单的负载均衡策略，提高系统性能和稳定性。

- **高可用性**：每个Server可以作为备用注册中心，一旦主注册中心下线，可以自动切换到备用注册中心，确保服务的连续性。

### 附加功能：消息的发布订阅 —— 基于主题，实现的消息转发

- **基本概念**：多个客户端围绕服务端进行消息的转发。

- **主题订阅**：在基础的消息转发功能上，实现基于主题的订阅，以满足更复杂的通信需求。

- **实现方式**：通过注册中心可以更简便地实现发布订阅功能，客户端订阅特定主题，服务端发布消息到该主题，所有订阅了该主题的客户端都能接收到消息。

## 项目主要功能


![项目大纲](/images/项目大框.png)

1. **RPC调用**：实现基本的远端调用功能，客户端发送请求到服务器，服务器处理并返回结果。

2. **服务的注册与发现**：
  - 服务提供者向注册中心注册服务。
  - 客户端通过注册中心发现服务。
  - 服务上下线时，注册中心通知相关客户端。
  
3. **消息的发布订阅**：
  - 客户端订阅特定主题的消息。
  - 服务端发布消息到指定主题，所有订阅了该主题的客户端都能接收到消息。

## 框架设计

### 服务端模块划分

### Network 模块

- 作为网络通信的基础，负责底层的网络通信实现。

	- **实现**：使用`Muduo`库搭建，利用其高性能的网络库特性，简化网络通信的复杂性。

### Protocol 模块

-  定义并解析应用层的通信协议，解决**粘包问题 —— 报文数据边界不明确**，确保消息完整性和类型识别。
	- 采用**特殊字符和定长**的方式效率较低，特殊字符会导致我们传递的无效数据增多。
	- **实现**：采用**LV格式**（Length-Value）定义协议，通过Length字段确定消息长度，MType字段确定消息类型，以此明确报文和报文之间的边界。

![Protocol模块](/images/protocol模块.png)

- **消息格式说明**：

	1. **Length（长度字段）**
  	- 字段长度：固定4字节
  	- 作用：表示后续本条消息数据的总长度。
	2. **MType（消息类型字段）**
  	- 字段长度：固定4字节
  	- 作用：标识该条消息的类型。
  	- 消息类型包括：
		- Rpc调用请求/响应类型消息
    	- 发布/订阅/取消订阅/消息推送类型消息
    	- 主题创建/删除类型消息
    	- 服务注册/发现/上线/下线类型消息
	3. **IDLength（ID长度字段）**
    
  	- 字段长度：固定4字节
  	- 作用：描述后续ID字段的实际长度。
  
	4. **MID（消息ID字段）**
  	- 字段特性：每条消息中的固定字段
  	- 字段长度：不固定，由IDLength字段指定
  	- 作用：唯一标识消息。
	5. **Body（消息正文数据字段）**
  	- 字段特性：消息的主题正文数据
  	- 作用：包含请求或响应的实际内容。
    
### 3. **Dispatcher**：消息分发处理模块
  - 负责接收到的消息的分发处理，根据消息类型将消息转发到相应的处理模块。
  
### 4. **RpcRouter**：远程调用路由功能模块

- **RpcRouter模块的意义**：RpcRouter模块的核心作用是提供处理RPC（远程过程调用）请求的回调函数,分辨出客户端请求的服务并进行响应。

- **RPC请求的关键要素**：

	1. **请求方法名称**：这指明了客户端希望服务端执行的具体操作或方法。
    
	2. **请求参数信息**：这些参数是执行指定方法所必需的输入数据。

**RPC 调用的流程**：

1. **建立通信链路**：首先，需要建立客户端与服务端之间的通信连接。
2. **发送请求**：客户端将需要调用的服务名称及参数信息打包，通过通信链路发送给服务端。
3. **服务端处理**：服务端接收请求后，进行解析并根据请求内容调用相应的处理逻辑。
4. **返回结果**：服务端将处理结果返回给客户端。
    
### 5. **Publish-Subscribe**：发布订阅功能模块

- 发布订阅模块用于处理发布订阅请求，并提供一个回调函数给`Dispatcher`模块使用。

**请求操作包含**：

- 主题的创建
- 主题的删除
- 主题的订阅
- 主题的取消订阅
- 主题消息的发布

**通信消息格式**：

- **Topic-request**（主题请求）：
  
  ```json
  {    "key": "music", // 主题名称    "optype": "TOPIC_CREATE/TOPIC_REMOVE/TOPIC_SUBSCRIBE/TOPIC_CANCEL/TOPIC_PUBLISH", // 主题操作类型    "message": "Hello World" // TOPIC_PUBLISH 请求才会包含此字段  }
  ```
  
- **Topic-response**（主题响应）：
  
  ```json
  {    "rcode": "OK"  }
  ```
  
  或
  
  ```json
  {    "rcode": "ERROR_INVALID_PARAMETERS"  }
  ```
  

**实现设计要点**：

1. **主题管理**：
  - 该模块必须具备一个主题管理功能。
  - 主题中需要保存订阅了该主题的客户端连接。
  - 当主题收到一条消息时，需要将这条消息推送给订阅了该主题的所有客户端。
2. **订阅者管理**：
  - 该模块必须具备一个订阅者管理功能。
  - 每个订阅者描述中都必须保存自己所订阅的主题名称。
  - 目的是当一个订阅客户端断开连接时，能够找到订阅信息的关联关系，并进行删除。
3. **业务处理函数**：
  - 该模块必须向外提供主题创建/销毁、主题订阅/取消订阅、消息发布处理的业务处理函数。
  
  
  
### 6. **Registry-Discovery**：服务注册/发现/上线/下线功能模块

- `Registry-Discovery`模块的核心功能是处理服务注册与发现请求，支持分布式架构下的服务动态感知。

**请求类型详细划分**：

1. **服务注册**：服务提供者（provider）向注册中心声明自己所能提供的服务。

2. **服务发现**：服务调用者（caller）向注册中心查询指定服务的提供者信息。

3. **服务上线**：当某个提供者成功上线指定服务后，通知之前发现过该服务的调用者，有新的提供者可以提供服务。

4. **服务下线**：当某个提供者断开连接或停止服务时，通知相关调用者，哪个服务已经下线。

**请求与响应格式**：

- **请求格式（RD-request）**：
  
  ```json
  {    "optype": "SERVICE_REGISTRY/SERVICE_DISCOVERY/SERVICE_ONLINE/SERVICE_OFFLINE",    "method": "Add",    "host": {      "ip": "127.0.0.1",      "port": 9090    }  }
  ```
  
  注：服务注册、上线、下线请求包含`host`字段，服务发现请求不包含。
  
- **响应格式**：
  
  - 成功响应（Registry/Online/Offline-response）：
    
    ```json
    {    "rcode": "OK"  }
    ```
    
  - 错误响应（error-response）：
    
    ```json
    {    "rcode": "ERROR_INVALID_PARAMETERS"  }
    ```
    
  - 服务发现响应（Discovery-response）：
    
    ```json
    {    "method": "Add",    "host": [      {"ip": "127.0.0.1", "port": 9090},      {"ip": "127.0.0.2", "port": 8080}    ]  }
    ```
    

**模块设计要点**：

1. **服务发现者管理**：

  - 记录谁发现过哪些服务，以便在新提供者上线时通知发现者。
  
  - 当发现者断开连接时，删除关联关系，避免无效通知。
  
2. **服务提供者管理**：

  - 监控提供者的连接状态，当提供者断开时，通知对应的发现者服务下线。
  
  - 跟踪提供者的方法状态，当方法下线时，通知发现过该方法的调用者。
  
3. **与Dispatcher模块集成**：

  - 提供服务注册/发现的业务处理回调函数给Dispatcher模块。
  
  - 当提供者注册服务时，将其纳入管理；当调用者发现服务时，返回相应的提供者信息。
  
  - 支持服务上线和下线通知，确保调用者能够及时感知服务状态的变化。
  
### 7. **Server**：基于以上模块整合的服务端模块


# 前置知识
## 异步操作

- 简单来说，如果一个操作不是发起操作的执行流自身完成的，那么它就是一个异步操作。
	- `std::future`用于用于同步保存一个异步任务的结果。

## 异步操作相关函数

### `std::async`模板函数，创建线程执行异步任务

- **功能**：**异步执行一个函数**，并返回一个`future`对象，该对象可用于获取函数的执行结果。它又有两种工作模式。
	- `std::launch::async`：`std::async`会尝试立即创建一个新线程来执行函数，并将函数的返回值与`std::future`对象的共享状态同步。
    
	- `std::launch::deferred`：表示`std::async`不会立即启动新线程来执行给定的任务，而是将任务的执行推迟到对返回的`std::future`对象的**wait或get方法**被调用时。
		- `get`如果没有结果就会阻塞。
    
- **返回值**：`std::future<T>`，其中`T`是函数返回值的类型。如果异步任务函数没有返回值，则`T`为`void`。

### `std::packaged_task`类模板，通过对一个函数进行封装，变成一个可调用对象

- **功能**：为一个函数（或可调用对象）生成一个异步任务对象，该对象本身是可调用的，并且可以用于在其他线程中执行该函数。

- **用途**：常用于将**任务封装后传递给其他线程执行**，与`std::future`一起使用以异步获取任务结果。

### `std::promise` 类模板，是对一个结果的封装

- **功能**：实例化的对象可以返回一个`std::future`对象，允许在其他线程中向`promise`对象设置数据（即结果），与之关联的`future`对象就可以获取这些数据。

- **使用**：在需要显式控制数据在异步操作间传递时非常有用，特别是当没有现成的函数或可调用对象可以封装为`std::packaged_task`时。

- **示例流程**：
  1. 创建`std::promise<T>`对象。
  2. 从该对象获取`std::future<T>`对象，用于后续获取数据。
  3. 在另一个线程中，通过调用`promise`对象的`set_value(T value)`方法设置数据。
  4. 使用`future`对象的`get()`方法从原始线程或其他线程中获取数据。
  
  
### 异步操作的移动语义

- 在C++11及以后的版本中，移动语义允许我们将资源的所有权从一个对象转移到另一个对象，而不是复制这些资源。

	1. 当我们创建一个`std::promise<int>`对象时，它可能需要在内部分配一些资源来存储与`std::future`通信所需的状态。
  
	2. 如果我们简单地通过值传递这个`promise`对象给另一个线程（例如，直接作为`std::thread`的构造函数参数），那么编译器会尝试复制这个对象。但是，由于`std::promise`是不可复制的（只有移动构造函数和移动赋值运算符是有效的），这样的直接传递会导致编译错误。
  
	3. 因此，我们使用移动语义来避免复制。通过将`promise`对象移动到另一个作用域（在`thread_function`函数的参数中）或通过使用`std::packaged_task`（它本身是可移动的），我们可以确保`promise`（或`packaged_task`）的所有权被安全地转移到新线程中，同时避免了不必要的资源复制。
  
	4. 在`std::packaged_task`的示例中，我们通过`std::move(task)`将`packaged_task`对象移动到新线程中。这样，原始`packaged_task`对象在移动后处于有效但未定义的状态（通常是“空”或“已移动”状态），而新线程中的`packaged_task`对象则包含了所有必要的资源来执行封装的任务，并与相应的`future`对象保持通信。