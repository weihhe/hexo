title: 易错易忘的内容
author: weihehe
tags: []
categories:
  - 易忘
date: 2024-07-13 12:07:00
---
持续整理中...
<!--more-->
## .C :

1. 对一个结构体取地址，取到的是**它结构体的起始地址**，也就是整个结构体的地址。

2. **我们如何获得一个函数的返回值的？**通过将需要返回的值拷贝（临时变量）到CPU寄存器，具体是哪一个寄存器由编译器决定。

3. **CPU是如何知道我们当前执行到那一行代码了的？EIP寄存器**。EIP（Instruction Pointer）指令指针寄存器： 存储 了当前正在执行的指令的内存地址。 当程序执行时，EIP会不断更新以指向下一条要执行的指令。

4. 数组名表示整个**数组**的情况：

	- **&数组名**，数组名表示整个数组，取出的是整个数组的地址。
	- **sizeof（单独一个数组名）**表示整个数组，计算的是整个数组的大小，单位是字节,返回的是unsign int 四个字节——sizeof是操作符，有时可以省略括号
	- **其余数组名都是首元素**

5. 可变参数列表如何实现的。
6. C语言要求文件以`\0`结束，因此写入的时候，字符串长度需要`+1`。
7. 优化会导致的死循环，需要添加`volatile`
```c
volatile int flag = 0;
void handler(int sig)
{
 printf("chage flag 0 to 1\n");
 flag = 1;
}
int main()
{
 signal(2, handler);
 while(!flag);
 printf("process quit normal\n");
 return 0;
}
```
8. 使用`&`运算符时，会得到变量的起始地址。这个地址是一个指向该变量的指针。当 CPU 读取数据时，它需要知道要读取的数据类型。编译器会根据变量的类型生成相应的机器指令，告诉 CPU 读取多少个字节。

9. `##`把两个宏参数贴合在一起。

10. `read`的结尾控制
- 确保 `buffer` 是一个实际的数组，而不是指针。
- 检查 `read` 的返回值，确保读取操作成功。
- 如果 `buffer` 用来存储字符串，手动添加 `\0` 终止符，例如：
```cpp
ssize_t n = read(fd, buffer, sizeof(buffer) - 1);
if (n >= 0) {
    buffer[n] = '\0'; // 手动添加字符串终止符
}
```


## 一些函数：
|函数名|作用|
|--|--|
|bzero|初始化一段地址|

## C++

1. `C++11` 引入了 <thread> 头文件及相关线程库，提供了跨平台的线程支持。而原生线程库通常是特定于某个平台的。使用这些库编写的代码需要在不同的平台上进行修改，以适应各个平台的 API。因此，这些原生线程库不具有跨平台性。

    
## Linux

- man手册对应的位置

| Manual Section Number | Description                                                             |
|-----------------------|----------------------------------------------------------------------------------------------|
| 1                     | User Commands: Commands that can be run from the shell (e.g., ls, grep).                     |
| 2                     | System Calls: Functions provided by the kernel (e.g., open, read).                           |
| 3                     | Library Functions: Functions found in program libraries (e.g., printf, malloc).              |
| 4                     | Special Files: Files found in /dev (e.g., /dev/null, /dev/random).                           |
| 5                     | File Formats and Conventions: File formats (e.g., /etc/passwd).                              |
| 6                     | Games: Games and screensavers.                                                               |
| 7                     | Miscellaneous: Miscellaneous commands and macros.                                            |
| 8                     | System Administration Commands: Commands used by system administrators (e.g., mount, ifconfig).|

- 非静态成员函数取地址前面要加`&`符号。
    
- `/dev/null` 它的主要作用是丢弃所有写入到它的数据，而不返回任何内容给读取它的进程。

- 操作和函数

|操作|意义|
|--|--|
|$?|返回最近一次返回值|
|`static_cast<class_name>(args)`|类似于强制转换的安全写法
|`ipconfig`|显示网络接口的IP配置等信息|

### PS指令
| 选项         | 描述                                            |
| ---------- | --------------------------------------------- |
| `-A`，`-e`  | 显示系统中所有的进程。                                   |
| `-a`       | 显示除会话领导者和没有控制终端的进程外的所有进程。                     |
| `-u`       | 以用户为基础显示进程的详细信息（如用户名、CPU 和内存使用情况等）。           |
| `-x`       | 显示没有控制终端的进程（通常是后台进程）。                         |
| -j         | 以作业格式（job format）显示进程信息。                      |
| `-f`       | 显示完整的格式信息，包括进程的父进程 PID 和启动时间等。                |
| `-l`       | 显示更详细的进程信息，以长格式列出。                            |
| `-p PID`   | 显示指定 PID 的进程信息。                               |
| `-o`       | 自定义输出格式，允许用户选择显示哪些列。例如：`ps -o pid,user,%cpu`。 |
| `-t TTY`   | 显示与指定终端相关的进程。                                 |
| `-r`       | 只显示正在运行的进程。                                   |
| `-n`       | 显示进程的优先级。                                     |
| `-H`       | 显示进程的层次结构，显示进程之间的父子关系。                        |
| `-N`       | 显示除指定用户外的所有进程。                                |
| `-C CMD`   | 仅显示指定命令名的进程。                                  |
| `-v`       | 显示内存使用量较大的进程。                                 |
| `--sort`   | 按指定列进行排序输出，例如按 CPU 使用率排序：`ps --sort=-%cpu`。   |
| `--forest` | 以树状结构显示进程的层次关系。                               |



## 网络

### `signal(SIGPIPE, SIG_IGN)`的作用：

- `signal(SIGPIPE, SIG_IGN)` 的意思是忽略 `SIGPIPE` 信号。通过这个设置，当试图写入一个已经关闭的 socket 时，进程不会收到 `SIGPIPE` 信号，因此也不会因此崩溃。

- 这种处理方式适用于需要确保程序稳定性的情况，尤其是在网络通信程序中，因为 socket 的对端可能在任意时刻关闭连接，如果不处理好 `SIGPIPE` 信号，程序可能会因为这个信号异常退出。

## Windowns

```cpp
#include <winsock2.h> //头文件展开顺序
#include <windows.h>
```