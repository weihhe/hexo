title: 如何大端模式和小端模式 指针 数组事项
author: weihehe
tags:
  - 大小端
  - 数组
  - 指针
categories:
  - 操作系统
date: 2024-07-05 17:17:00
---
## 实验判断计算机的大小端和数组，指针的一些注意事项
<!-- more -->

```cpp
short num  = 1;
short num_2  = 8192;
char* p_ch = ((char*)(&num));
char* p_ch_2 = ((char*)(&num_2));
int main()
{
    printf("%d\n",*p_ch);
    printf("%d\n",0b0000000000000001);
    printf("%d\n",*p_ch_2);
    printf("%d\n",0b0010000000000000);

    return 0;
}

```
### 分析

**原理**：利用了`*char`来取出`shourt`低地址一字节的数据。
（假设**shourt是双字节,char是单字节**）

1. 如果是**小端模式**:低地址保存低位数据

	- `*p_ch` 打印 1，因为1的低位一字节数据是0b0000001。
	- `*p_ch_2` 打印 0，因为8192的低位一字节数据是0b0000000。

2. 如果是**大端模式**:低地址保存高位数据

	- *p_ch 打印 0，因为在大端模式下，1的高位一字节是0b0000000。

	- *p_ch_2 打印 32，因为在大端模式下，8192的高位一字节是0b001000。
    
    
## 一些指针事项
   
 - 指针+-整数 就是跳过几个该指针的类型。
 
- 地址（指针）-地址（指针）的意义就是，差了几个元素——前提：两个指针指向同一个地址空间。

- 我们可以通过指针算术来获得指向其他元素的指针，例如 arr + 1 指向 arr[1]，并且指针算术和比较允许将指针与数组的**结束位置进行比较，但不能和第一个元素之前的位置进行比较**。
	- 例如：
    
    ```cpp
    for (int* p = arr; p < arr + 5; ++p) {
    printf("%d ", *p);//遍历数组
    /* 非法的比较 while (p >= arr - 1) 这种比较是无效的，因为指针不能指向第一个元素之前的位置*/ 
    }	
   ```
   
- 决定了指针进行解引用操作的时候，一次性访问几个字节，取决于指针的类型。
- 函数指针的使用


## 一些数组事项
- 数组名表示整个**数组**的情况：

	- &数组名，数组名表示整个数组，取出的是整个数组的地址。
	- sizeof（单独一个数组名）表示整个数组，计算的是整个数组的大小，单位是字节,返回的是unsign int 四个字节——sizeof是操作符，有时可以省略括号
	- 其余数组名都是首元素