title: C++中的默认成员函数 现代写法
author: weihehe
tags: []
categories:
  - C++
date: 2024-07-03 10:48:00
---
8个默认成员函数
<!-- more -->
8个默认成员函数，“默认”的意思就是指我们不写，编译器会变我们自动生成

- **默认构造函数（Default Constructor）**
- **拷贝构造函数（Copy Constructor）**
- **拷贝赋值运算符（Copy Assignment Operator）**
- **析构函数（Destructor）**
- **移动构造函数（Move Constructor，C++11 引入）**
- **移动赋值运算符（Move Assignment Operator，C++11 引入）**
- **取地址重载**
- **const取地址重载**

### 初始化和清理

1. 构造完成初始化。
2. 析构函数完成清理。

*由于多态的原因，所有**析构函数的函数名都被处理为了destructor**，所以在派生类调用基类的析构时，需要指定基类域——但都使用自动调用，用于保证析构顺序。*

### 析构函数处理为多态的原因


![**导致内存泄漏**](/images/默认成员函数-01.png)

1. 需要给析构函数加上**virtual**。
2. 所有的析构函数都被处理为destructor()，所以他们满足**重写的条件**
3. `delete p`可以看作`p->destructor()`满足指针或者引用调用的条件。（具体查看多态)

**所以，一个类如果要被继承，那么它的析构函数就需要用`virtual`修饰，形成析构函数的多态。**

### 拷贝构造

![拷贝构造](/images/成员函数_copy_and_structure.png)
1. 拷贝构造用于同类对象初始化创建对象，是**构造函数的一种重载形式**。使用const防止

2. 拷贝构造的参数只有一个且必须是**拷贝对象的引用**，如果使用传值的方式，编译器将直接报错，因为会引发无穷递归调用。 

### 赋值拷贝

![upload successful](/images/assignment_copy.png)
*图中为了防止**隐藏**，要指定在基类`person::`*

#### 注意事项：

 1. 已经存在的两个对象之间赋值拷贝——运算符重载函数。赋值重载主要是吧一个对象赋值给另一个对象。
 2. 参数类型为const T&，传递引用可以提高传参效率。
 3. 返回类型为：T&，有返回值的目的是为了支持连续赋值。
 4. 检查是否自己给自己赋值，一般比较地址（为了提高效率）。
 5. 返回*This：符合连续赋值的含义。
 6. 用户没有显式实现时，编译器会生成一个默认赋值运算符重载，所以不可将赋值运算符重载定义为全局的函数，避免在使用时的不明确。

### 取地址重载
1. 普通对象取地址。
2. const对象取地址。

### “现代写法”
![现代写法](/images/Modern_Writing.png)
在这里的表现为在拷贝构造当中调用构造函数。


## 移动构造

- 如果没有自己实现**移动构造**，并且没有实现**析构函数**，**拷贝构造**，**拷贝赋值**，（三个都没有）那么编译器会自动生成一个移动构造。默认的移动构造：

	- 对于内置类型，则执行逐成员的字节拷贝。
	- 对于自定义类型来说
    	- 如果实现移动构造，那么就调用它。
		- 如果没有实现移动构造，那么就去调用拷贝构造。

## 强制生成成员函数

可以通过 = default 语法来实现——如下：
```cpp
class MyClass {
public:
    // 默认生成拷贝构造函数
    MyClass(const MyClass&) = default;
};

```