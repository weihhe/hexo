title: 重载
author: weihehe
tags:
  - 重载
categories:
  - C++
date: 2024-07-31 10:43:00
---
重载的原理细节
<!-- more -->
## 重载

重载的底层——函数名修饰规则。
不同编译器的函数命名规则也不同。

![VS中的函数名修饰规则](/images/overload_style.png)

cpp程序运行时，函数地址会在**编译阶段通过函数命名规则（即函数重载）**初步确定（可能存在相对地址），解决了函数重载的问题。
在**链接阶段**，链接器通过符号表确定需要**调用的函数的最终地址。**然而，**内联函数**通常在调用点直接展开，**不会进入了符号表**。


### 条件

1. 同一作用域，函数名字相同。
2. 参数个数不同
3. 参数顺序不同（不同一类型）
4. 参数类型不同（且不一定要有参数）

**返回值类型不同不能构成重载**！，原因是因为，在**编译阶段**就会检查是否有函数可供重载，在此阶段调用函数的时候，还**没有返回值可供检查。**

**{1}条件与{2，3，4}任一条件同时满足的时候即构成重载**。

## 运算符重载

1. 可以显示调用。
2. 会被当做一个成员函数。
3. 有两种调用方式，且左操作数和右操作数重载后的实际关系如下图所示。
![upload successful](/images/这里重载了<符号.png)

4. 不能通过连接其他符号来创建新的操作符。
5. 是否要重载运算符，关键在于这个运算符对于这个类是否有意义。
6. 用于内置类型的运算符，其含义不能改变，例如：内置的整型'＋'，不能政变其含义。
7. 作为类成员函数重载时，其形参看起来比操作数数目少一个，因为成员函数的第一个参数为**隐藏的this** 。实际情况下的操作数应该和形参个数相同。
8. {* sizeof  ?  :  . } 5个运算符不能重载

### 关于自增自减

在自定义类型进行自增自减操作的时候，应尽量使用前置操作符，因为可以避开**深拷贝**。
例如：
**后置中的int，仅仅是为了占位，无实意**
![前后置的写法差别](/images/deeply_copy.png)


## 内联函数

1. 内联只是一种建议，编译器不一定会采纳。
2. 如果一个内联函数跨多个翻译单元使用，或者它的地址被占用，它可能仍然需要符号表中的一个条目。
3. 内联避免了对符号表项的需要，从而减少了函数调用开销。

![重载在何时发生？](/images/overload.png)