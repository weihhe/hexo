title: 小总结
author: weihehe
tags: []
categories: []
date: 2024-09-01 08:32:00
---
突击测试
<!--more-->

C11

| 特性名称 | 描述  |
| --- | --- |
| auto关键字 | 自动类型推断，减少类型声明的冗余 |
| 统一的列表初始化 | 使用大括号`{}`进行初始化，支持所有内置类型和用户自定义类型 |
| nullptr | 替代NULL和0，表示空指针，类型安全 |
| lambda表达式 | 允许定义匿名函数对象，简化代码 |
| 范围for循环 | 简化容器遍历，提高代码可读性 |
| decltype | 用于推导一个表达式的类型，用于类型声明 |
| 右值引用和移动语义 | 支持移动语义，提高对象传递和返回的效率 |
| std::initializer_list | 一种特殊的类型，用于表示大括号括起来的初始化列表 |
| 智能指针 | `std::unique_ptr`、`std::shared_ptr`和`std::weak_ptr`，自动管理内存 |
| constexpr | 编译时常量表达式，允许在编译时计算值 |
| 类型别名声明 | 使用`using`或`typedef`为类型定义新名称 |
| 无序容器 | `std::unordered_set`和`std::unordered_map`，提供高效的哈希表实现 |
| static_assert | 编译时断言，确保编译时满足特定条件 |
| 可变参数模板 | 支持任意数量和类型的模板参数 |
| 委托构造函数 | 允许在构造函数内部调用同一个类的另一个构造函数 |
| 继承构造函数 | 允许子类继承父类的构造函数 |
| 原始字面量 | 提供了一种表示原始字符串字面量的方式 |
| enum class | 强类型枚举，提供更安全、作用域更明确的枚举类型 |
| std::array | 固定大小的数组容器，比C语言数组更安全、方便 |
| std::forward_list | 单向链表容器，支持快速插入和删除操作 |
| std::tuple | 异构值集合，可以存储不同类型的数据 |
| std::bind | 用于绑定函数调用的参数，生成新的可调用对象 |
| std::function | 通用函数包装器，可以存储、调用任何可调用对象 |
| noexcept关键字 | 用于指定函数是否抛出异常，提高代码安全性和性能 |
| override和final关键字 | `override`用于显式指定函数重写基类虚函数，`final`用于禁止类被继承或函数被重写 |



| STL名称       | STL作用                                          | STL方法（部分）                                          |  
| ------------- | ------------------------------------------------ | -------------------------------------------------------- |  
| `vector`      | 动态数组，支持快速随机访问                       | `push_back()`, `pop_back()`, `at()`, `operator[]`        |  
| `list`        | 双向链表，支持快速插入和删除                     | `push_back()`, `push_front()`, `pop_back()`, `pop_front()`|  
| `deque`       | 双端队列，支持头尾快速插入和删除                 | `push_back()`, `push_front()`, `pop_back()`, `pop_front()`|  
| `set`         | 有序集合，自动排序且不包含重复元素               | `insert()`, `erase()`, `find()`, `count()`               |  
| `map`         | 有序键值对集合，键自动排序，键唯一               | `insert()`, `erase()`, `find()`, `operator[]`             |  
| `unordered_set`| 无序集合，不包含重复元素，基于哈希表实现         | `insert()`, `erase()`, `find()`, `count()`               |  
| `unordered_map`| 无序键值对集合，基于哈希表实现，键唯一           | `insert()`, `erase()`, `find()`, `operator[]`             |  
| `stack`       | 栈，后进先出（LIFO）数据结构                     | `push()`, `pop()`, `top()`, `empty()`                    |  
| `queue`       | 队列，先进先出（FIFO）数据结构                   | `push()`, `pop()`, `front()`, `back()`, `empty()`         |  
| `priority_queue`| 优先队列，最高优先级元素总是位于队列的前端       | `push()`, `pop()`, `top()`, `empty()`                    |  
| `algorithm`   | 一系列算法函数，如排序、查找等                   | `sort()`, `search()`, `find()`, `copy()`, `reverse()`    |  
| `iterator`    | 迭代器，用于遍历容器中的元素                     | `begin()`, `end()`, `++`, `--`, `*`, `->`                |  
| `functional`  | 函数对象和函数适配器，支持函数回调和组合         | `std::bind()`, `std::mem_fn()`, `std::function<>`         |  
| `memory`      | 内存管理工具和智能指针，帮助管理动态分配的内存   | `std::unique_ptr<>`, `std::shared_ptr<>`, `std::weak_ptr<>`|  
| `utility`     | 实用工具，包括`pair`和`tuple`等数据结构          | `std::pair<>`, `std::tuple<>`, `std::make_pair()`          |  
| `string`      | 字符串类，封装了C风格字符串，提供更多功能        | `operator+`, `append()`, `substr()`, `find()`            |  
| `iostream`    | 输入输出流，支持文件、内存和字符串的读写操作     | `std::cin`, `std::cout`, `std::cerr`, `>>`, `<<`           |

设计模式

| 设计模式类型 | 名称          | 描述                                                     |  
|--------------|---------------|----------------------------------------------------------|  
| **创建型**   | 单例模式      | 确保一个类仅有一个实例，并提供一个全局访问点。           |  
|              | 原型模式      | 通过复制原型对象来创建新的对象。                         |  
|              | 工厂方法模式  | 定义一个用于创建对象的接口，让子类决定实例化哪一个类。    |  
|              | 抽象工厂模式  | 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 |  
|              | 建造者模式    | 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 |  
| **结构型**   | 适配器模式    | 将一个类的接口转换成客户期望的另一个接口。               |  
|              | 桥接模式      | 将抽象部分与它的实现部分分离，使它们都可以独立地变化。    |  
|              | 组合模式      | 将对象组合成树形结构以表示“部分-整体”的层次结构。        |  
|              | 装饰器模式    | 动态地给一个对象添加一些额外的职责。                     |  
|              | 外观模式      | 为子系统中的一组接口提供一个一致的界面。                 |  
|              | 享元模式      | 运用共享技术有效地支持大量细粒度的对象。                 |  
|              | 代理模式      | 为其他对象提供一种代理以控制对这个对象的访问。           |  
| **行为型**   | 观察者模式    | 定义对象间的一种一对多的依赖关系，当一个对象改变状态，所有依赖于它的对象都会得到通知并被自动更新。 |  
|              | 模板方法模式  | 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。    |  
|              | 命令模式      | 将一个请求封装为一个对象，从而使你可用不同的请求把客户端与服务操作解耦。 |  
|              | 状态模式      | 允许一个对象在其内部状态改变时改变它的行为。              |  
|              | 策略模式      | 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。 |  
|              | 职责链模式    | 避免请求发送者与多个接收者耦合在一起。                   |  
|              | 访问者模式    | 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。    |  
|              | 备忘录模式    | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 |  
|              | 解释器模式    | 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 |  
  



极小极大算法（Minimax算法）

- 定义与原理：极小极大算法是一种找出失败的最大可能性中的最小值的算法。它常用于两方较量的游戏，如棋类游戏。该算法是一个零总和算法，意味着一方得益必然导致另一方等量的损失，总和为零。算法以递归形式实现，每个递归步骤都会评估当前局面下所有可能的走法，并选择最优的一个。

- 应用与实现：

在棋类游戏中，极小极大算法通过构建搜索树来探索所有可能的未来走法。每个节点代表一个游戏状态，边代表从一个状态到另一个状态的移动。算法从当前状态开始，逐层向下搜索，直到达到预定的搜索深度。
- 评估与选择：
对于每个叶节点（即搜索树的末端状态），使用一个评估函数来评估该状态的优劣。
评估函数根据游戏的具体规则来设计，通常考虑双方棋子的位置、数量等因素。根据评估函数的返回值，选择对当前玩家最有利的走法。

- Alpha-Beta剪枝算法
定义与目的：
- Alpha-Beta剪枝是一种优化技术，用于减少极小极大算法在搜索过程中的节点数，从而提高搜索效率。它通过剪去不影响最终决策的分枝来减少搜索空间。

	- 原理与实现
		- Alpha-Beta剪枝算法在搜索过程中维护两个值：alpha和beta。
Alpha代表当前玩家能够确保获得的最小利益，beta代表对手能够确保获得的最大利益。在搜索过程中，如果某个节点的评估值低于alpha或高于beta，则该节点及其子树将被剪枝，即不再进一步搜索。