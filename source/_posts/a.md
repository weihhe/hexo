title: 进程
tags:
  - 进程
categories:
  - 操作系统
  - ''
author: weihehe
date: 2024-06-17 16:48:00
---
Linux下进程相关，如PCB，fork()，调度器，写时拷贝
<!-- more -->
## 进程

被装载到了**内存的程序**被称为进程，并使用PCB来对进程进行管理。

### 构成

 **内核数据结构对象(PCB)**（进程属性的集合） + 代码 + 数据

![upload successful](/images/pasted-0.png)


 
## PCB

PCB(Process Control Block)

目的是为了方便操作系统去管理数据进程，将对进程的管理，转化为对PCB的管理。

 <ins>例如:task_struct是linux内核的一种用于管理进程的数据结构

### PCB构成

任何一个程序，在加载到一个内存的时候，都要先 **创建PCB（进程控制块）** 来管理它。**PCB**中记录了许多有关运行进程的重要信息，包括进程的状态，进程运行的内存信息，优先级等等

![upload successful](/images/PCB.png)

## 进程信息


### 使用ps命令实时监测pid

**替换process-name**

```bash
while : ; do 
    ps ajx | head -1
    ps -C process-name -o pid,cmd
    echo "---------------------"
    sleep 1
done
```
**grep在过滤时自身也会变成一个进程**，并且可能携带process-name信息，成为**ps**的一个干扰项

在操作系统内核中进程创建之后，我们需要通过系统调用接口 **getpid()** 才能获得进程的pid，并且只保证在本次运行期间pid有效

**PPID(parent process ID)**:也可以通过getppid()获取。

---

可以看到此时父进程的pid值不变

![upload successful](/images/ppid_pid.png)

查询该处的父进程

可以看到bash字段,即 **bash** 进程，即命令行解释进程。几乎所有shell指令都是它的子进程

![upload successful](/images/bash_pid.png)


### 创建一个子进程

在linux下，可以通过**fork**函数在代码运行期间创建一个子进程。

1. 创建子进程PCB，并填充内容，并且可以被cpu同时调度

2. 父子进程指向相同的代码

```md
Fork - RETURN VALUE
       On success, the PID of the child process is returned in the parent, and 0 is returned  in  the  child. 
       On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately.
```

**fork的运行逻辑和使用**

- 由于父子进程的fork返回值不同，于是我们可以通过返回值来对父子进程进行控制

- 对于子进程而言只有一个父进程，所以只需要用‘0’来表示父进程即可，而对于父进程可能有不同的子进程，于是需要记录子进程的pid

子进程的创建也会产生新的PCB，并且和父进程**共享代码**。
（程序中**代码段不可更改**）进程在运行的时候，**是独立的**，因此父子进程并**不共享数据** 避免了数据相互影响。

**因此，子进程在创建时，会通过父进程拷贝一份数据**。

### 写时拷贝

但子进程不一定会访问所有数据，全部拷贝数据可能产生冗余与浪费，因此操作系统会检查子程序中是否有对数据的修改，如果涉及到修改，那么才会针对数据进行拷贝，并将其归属于子进程，这种技术就叫——**数据层面的写时拷贝**。

### fork()两个返回值？

fork()的“两个返回值”生产的原因：

1. 父子进程都能被调度,并且父子进程谁先运行，都是由**调度器**来决定的

2. 子进程和父进程共享fork之后的代码，其中包含**return语句** ，于是父子进程都分别进行了return操作

## Linux进程的状态


![upload successful](/images/process_state.png)


如果我们使用类似双链表的结构维护进程，链表中保存的是进程的PCB。则对于cpu而言，管理这些进程就是要**维护进程运行的队列**

### 运行态

**假设**：我们只有**一个CPU**,我们将随时可以被调度的进程都放进到一个队列当中，那这个队列就叫做**运行队列** ，当一个进行需要被运行时，把它添加到这个队列即可，这个队列当中进程的状态就叫做**运行态**。

### 时间片

为了防止运行队列中某一个进程运行时间过长从而导致**队列中从它往后**的进程迟迟不能被CPU运行，引入了**时间片**的概念，即某个进程最长可以运行的时间，在时间片结束后，都要出队列，如果还需要运行，那再入队列。因此会产生大量出队入队的操作。

对于CPU来说，一出一进的过程就叫做**进程的切换**。

### 阻塞

在**等待特定资源的进程**，我们叫做**阻塞**。
 
假设一个进程，他需要从键盘读入数据，但是**键盘当前没有就绪，没有数据可读**，则它将位于键盘的**等待队列中** ,此时它就是**阻塞**的，当设备可读后，**再将进程放到运行队列里**，等待cpu调度读取数据。

以上由阻塞变为运行态的过程就叫做**进程的唤醒**。


### 挂起

**当一个进程没有被真正调度的时候，它的数据都暂存到内存中。**

假设非常多的进程目前都等待队列中，但内存资源已经不足，此时操作系统只会将**进程的PCB保留**，而将**代码和数据归还到外设中** ,从而节约内存。此时该进程的状态就叫做**挂起**。

这部分用于**换入换出内存资源**的空间，就是**swap（交换分区）**。