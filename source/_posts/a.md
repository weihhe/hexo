title: 进程属性和状态
tags:
  - 进程
categories:
  - 操作系统
  - ''
author: weihehe
date: 2024-06-17 16:48:00
---
Linux下进程相关，如PCB，fork()，调度器，写时拷贝
<!-- more -->
## 进程

被装载到了**内存的程序**被称为进程，并使用PCB来对进程进行管理。

### 构成

 ** 内核数据结构对象(PCB) **（进程属性的集合） + 代码 + 数据

![upload successful](/images/pasted-0.png)


 
## PCB

PCB(Process Control Block)

目的是为了方便操作系统去管理数据进程，将对进程的管理，转化为对PCB的管理。

 <ins>例如:task_struct是linux内核的一种用于管理进程的数据结构

### PCB构成

任何一个程序，在加载到一个内存的时候，都要先 **创建PCB（进程控制块）** 来管理它。**PCB**中记录了许多有关运行进程的重要信息，包括进程的状态，进程运行的内存信息，优先级等等

![upload successful](/images/PCB.png)

## 进程信息


### 使用ps命令实时监测pid(或者top)

**替换process-name**

```bash
while : ; do 
    ps ajx | head -1
    ps -C process-name -o pid,cmd
    echo "---------------------"
    sleep 1
done
```
**grep在过滤时自身也会变成一个进程**，并且可能携带process-name信息，成为**ps**的一个干扰项

在操作系统内核中进程创建之后，我们需要通过系统调用接口 **getpid()** 才能获得进程的pid，并且只保证在本次运行期间pid有效

**PPID(parent process ID)**:也可以通过getppid()获取。

---

可以看到此时父进程的pid值不变

![upload successful](/images/ppid_pid.png)

查询该处的父进程

可以看到bash字段,即 **bash** 进程，即命令行解释进程。几乎所有shell指令都是它的子进程

![upload successful](/images/bash_pid.png)


### 创建一个子进程

在linux下，可以通过**fork**函数在代码运行期间创建一个子进程。

1. 创建子进程PCB，并填充内容，并且可以被cpu同时调度

2. 父子进程指向相同的代码

```md
Fork - RETURN VALUE
       On success, the PID of the child process is returned in the parent, and 0 is returned  in  the  child. 
       On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately.
```

**fork的运行逻辑和使用**

- 由于父子进程的fork返回值不同，于是我们可以通过返回值来对父子进程进行控制。
	
    - 例如：
    ```cpp
    pid_id id = fork();
    if(id)== 0{
		//....子进程逻辑
		}
		else{
		父进程逻辑
        }
    ```

- 对于子进程而言只有一个父进程，所以只需要用‘0’来表示父进程即可，而对于父进程可能有不同的子进程，于是需要记录子进程的pid

子进程的创建也会产生新的PCB，并且和父进程**共享代码**。
（程序中**代码段不可更改**）进程在运行的时候，**是独立的**，因此父子进程并**不共享数据** 避免了数据相互影响。

**因此，子进程在创建时，会通过父进程拷贝一份数据**。

### 写时拷贝

但子进程不一定会访问所有数据，全部拷贝数据可能产生冗余与浪费，因此操作系统会检查子程序中是否有对数据的修改，如果涉及到修改，那么才会针对数据进行拷贝，并将其归属于子进程，这种技术就叫——**数据层面的写时拷贝**。

### fork()两个返回值？

fork()的“两个返回值”生产的原因：

1. 父子进程都能被调度,并且父子进程谁先运行，都是由**调度器**来决定的

2. 子进程和父进程共享fork之后的代码，其中包含**return语句** ，于是父子进程都分别进行了return操作


## Linux进程的状态
```c
/ * The task state array is a strange "bitmap" of* reasons to sleep. Thus "running" is zero, and
 * you can test for combinations of others with
 * simple bit tests.
 */
 static const char * const task_state_array[] = {
 "R (running)", /* 0 */
 "S (sleeping)", /* 1 */
 "D (disk sleep)", /* 2 */
 "T (stopped)", /* 4 */
 "t (tracing stop)", /* 8 */
 "X (dead)", /* 16 */
 "Z (zombie)", /* 32 */
 };
```
![upload successful](/images/process_state.png)


如果我们使用类似双链表的结构维护进程，链表中保存的是进程的PCB。则对于cpu而言，管理这些进程就是要**维护进程运行的队列**

### 运行态（`R`）

**假设**：我们只有**一个CPU**,我们将随时可以被调度的进程都放进到一个队列当中，那这个队列就叫做**运行队列** ，当一个进行需要被运行时，把它添加到这个队列即可，这个队列当中进程的状态就叫做**运行态**。

### 时间片

为了防止运行队列中某一个进程运行时间过长从而导致**队列中从它往后**的进程迟迟不能被CPU运行，引入了**时间片**的概念，即某个进程最长可以运行的时间，在时间片结束后，都要出队列，如果还需要运行，那再入队列。因此会产生大量出队入队的操作。

对于CPU来说，一出一进的过程就叫做**进程的切换**。

### 阻塞——浅度睡眠（`s`）

- 浅度睡眠 —— **随时可以改变它的状态**。

- 在**等待特定资源的进程**，我们叫做**阻塞**。——每个都具有等待队列。*并且大多数任务都处于这个状态。*
 
假设一个进程，他需要从键盘读入数据，但是**键盘当前没有就绪，没有数据可读**，则它将位于键盘的**等待队列中** ,此时它就是**阻塞**的，当设备可读后，**再将进程放到运行队列里**，等待cpu调度读取数据。


以上由阻塞变为运行态的过程就叫做**进程的唤醒**。

### 阻塞——深度睡眠(`d`)

假如一个进程，它需要向磁盘写入大量数据（高IO状态），此时需要较多时间。因为涉及到的数据量大，进程`等待`磁盘的`返回信息`的期间，要保证这个进程不能被`kill`,从而正确的处理磁盘数据。此时就是 —— `深度睡眠(D)`状态,此时`它不响应任何请求`。

### 挂起

**当一个进程没有被真正调度的时候，它的数据都暂存到内存中。**

假设非常多的进程目前都等待队列中，但内存资源已经不足，此时操作系统只会将**进程的PCB保留**，而将**代码和数据交换到外设中（磁盘的交换分区）** ,从而节约内存。此时该进程的状态就叫做**挂起**。

这部分用于**换入换出内存资源**的空间，就是**swap（交换分区）**。

### 暂停状态（`T`）

也可以理解成阻塞，**但可能没有在等待任何资源，或正在被其他进程控制**。

- 例如：触发断点暂停。

使用`kill -19`给进程发送`19`号信号可以暂停进程。
*使用 kill -l 可以查看kill命令各个信号量
的意义*。

### 僵尸进程（`Z`）

当**进程结束的时候**，进程会**进入到这个状态中**，**直到父进程来回收它的资源。**

如果父进程**没有主动回收子进程**，那么子进程会**一直处于`Z`状态**。尤其是task_struct结构体不能被释放**。

- 最终会导致内存泄漏

### 终止态（`X`）

运行结束的进程，会标记为这个状态，并进入垃圾回收队列。

### 孤儿进程

对于父子进程而言，如果父进程先退出，子进程的父进程会被改`1号进程`，即`操作系统`，目的是为了回收子进程的信息。

## 现场保护（上下文切换）

当进程被CPU结束调度时，要将自己的上下文数据保存好，即**现场保护**便于被再次调度时恢复数据。例如将`eax`,`ebc`,`eip`等寄存器内的值，保存到一个结构体中。等到**现场恢复**的时候，再将这些值放回到寄存器中。