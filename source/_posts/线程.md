title: 线程 热数据
author: weihehe
tags:
  - 线程
  - Cache
categories:
  - 多线程
date: 2024-07-25 01:44:00
---
Linux中线程的概念和控制
<!--more-->
## 概念

- 线程是进程的**内**执行的，线程是在进程的地址空间内运行的。线程的执行粒度比进程更细。

- 任何执行流执行，都要有资源。线程就是利用了进程的**进程地址空间资源**。并且**线程中的大部分资源都是共享的**。

- **线程是操作系统调度的基本单位。而进程是承担操作系统分配资源的基本实体。**
 	
	- 进程包含了线程，用来描述管理线程的结构是线程控制块（`TCB`，Thread Control Block）。在Linux中，线程和进程的管理都通过任务结构（task_struct）来实现，因此，Linux的线程和进程使用同样的机制进行管理。
    
	- 由于这种设计，**Linux没有单独的TCB结构**，而是复用了`PCB`结构来管理线程。因此，虽然Linux有线程的概念，但线程和进程在内核层面并没有本质区别。
    
### 线程的结构

#### 独立结构
独立的栈结构，保证线程之间执行流独立。

独立的上下文，保证出线程是被独立调度的。

#### 共享部分
- 文件描述符表。
- 每种信号的处理方式。(SIG_ IGN、SIG_ DFL或者自定义的信号处理函数)
- 当前工作目录。
- 用户id和组id。

### 如何让线程执行不同的代码？

由于每个函数地址都不一样，那么只要让每个函数让不同的线程去跑，就已经实现了线程的分离。

### 线程的切换 

线程的切换比起进程切换更加轻量。

Cache:CPU进行**线程**切换的时候，上下文会切换，但是Cache不会被重启缓存。只有在**进程**切换的时候，Cache数据才会被重新缓存。其中Cache中的数据叫做`热数据`。

其中，刚启动的线程叫做主线程。

### 线程异常
- 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃。

- 线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出。

### 线程用途

- 合理的使用多线程，能提高CPU密集型程序的执行效率。
- 合理的使用多线程，能提高IO密集型程序的用户体验。（如生活中我们一边写代码一边下载开发工具，就是多线程运行的一种表现）

### 创建线程

- 线程的创建对应的函数是pthread_create()，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。

- pthread_create()不是一个系统调用，



### 线程相关的函数

| 函数           | 原型                                                                                       | 描述                                                               |
|----------------|------------------------------------------------------------------------------------------|--------------------------------------------------------------------|
| pthread_create | `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);` | 创建一个新的线程。                                                |
| pthread_exit   | `void pthread_exit(void *retval);`                                                        | 终止调用线程，并返回一个值。                                       |
| pthread_join   | `int pthread_join(pthread_t thread, void **retval);`                                       | 等待一个线程终止。                                                 |
| pthread_detach | `int pthread_detach(pthread_t thread);`                                                    | 分离线程，使其在终止时自动释放资源。                               |
| pthread_self   | `pthread_t pthread_self(void);`                                                            | 获取调用线程的线程ID。                                             |
| pthread_equal  | `int pthread_equal(pthread_t t1, pthread_t t2);`                                           | 比较两个线程ID是否相等。                                           |
| pthread_cancel | `int pthread_cancel(pthread_t thread);`                                                    | 向线程发送取消请求。                                               |
| pthread_once   | `int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));`               | 确保某个初始化函数仅执行一次。                                     |
| pthread_key_create | `int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));`                  | 创建线程特定数据的键。                                             |
| pthread_key_delete | `int pthread_key_delete(pthread_key_t key);`                                              | 删除线程特定数据的键。                                             |
| pthread_setspecific | `int pthread_setspecific(pthread_key_t key, const void *value);`                         | 设置线程特定数据的值。                                             |
| pthread_getspecific | `void *pthread_getspecific(pthread_key_t key);`                                          | 获取线程特定数据的值。                                             |
| pthread_mutex_init  | `int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);`       | 初始化互斥量。                                                     |
| pthread_mutex_destroy | `int pthread_mutex_destroy(pthread_mutex_t *mutex);`                                     | 销毁互斥量。                                                       |
| pthread_mutex_lock | `int pthread_mutex_lock(pthread_mutex_t *mutex);`                                       | 加锁互斥量。                                                       |
| pthread_mutex_trylock | `int pthread_mutex_trylock(pthread_mutex_t *mutex);`                                    | 尝试加锁互斥量（非阻塞）。                                         |
| pthread_mutex_unlock | `int pthread_mutex_unlock(pthread_mutex_t *mutex);`                                     | 解锁互斥量。                                                       |
| pthread_cond_init   | `int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);`         | 初始化条件变量。                                                   |
| pthread_cond_destroy | `int pthread_cond_destroy(pthread_cond_t *cond);`                                        | 销毁条件变量。                                                     |
| pthread_cond_wait   | `int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);`                 | 等待条件变量。                                                     |
| pthread_cond_signal | `int pthread_cond_signal(pthread_cond_t *cond);`                                       | 发信号通知一个等待条件变量的线程。                                 |
| pthread_cond_broadcast | `int pthread_cond_broadcast(pthread_cond_t *cond);`                                    | 发信号通知所有等待条件变量的线程。                                 |
| pthread_attr_init   | `int pthread_attr_init(pthread_attr_t *attr);`                                         | 初始化线程属性对象。                                               |
| pthread_attr_destroy | `int pthread_attr_destroy(pthread_attr_t *attr);`                                        | 销毁线程属性对象。                                                 |
| pthread_attr_setdetachstate | `int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);`          | 设置线程分离状态属性。                                             |
| pthread_attr_getdetachstate | `int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);`   | 获取线程分离状态属性。                                             |
| pthread_attr_setschedpolicy | `int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);`               | 设置线程调度策略属性。                                             |
| pthread_attr_getschedpolicy | `int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);`        | 获取线程调度策略属性。                                             |
| pthread_attr_setschedparam | `int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);` | 设置线程调度参数属性。                                             |
| pthread_attr_getschedparam | `int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);`  | 获取线程调度参数属性。                                             |

